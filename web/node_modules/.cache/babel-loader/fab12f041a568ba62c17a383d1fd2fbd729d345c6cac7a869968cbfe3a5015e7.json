{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRequestError = exports.APIResponseError = exports.UnknownHTTPResponseError = exports.isHTTPResponseError = exports.RequestTimeoutError = exports.isNotionClientError = exports.ClientErrorCode = exports.APIErrorCode = void 0;\nconst helpers_1 = require(\"./helpers\");\n/**\n * Error codes returned in responses from the API.\n */\nvar APIErrorCode;\n(function (APIErrorCode) {\n  APIErrorCode[\"Unauthorized\"] = \"unauthorized\";\n  APIErrorCode[\"RestrictedResource\"] = \"restricted_resource\";\n  APIErrorCode[\"ObjectNotFound\"] = \"object_not_found\";\n  APIErrorCode[\"RateLimited\"] = \"rate_limited\";\n  APIErrorCode[\"InvalidJSON\"] = \"invalid_json\";\n  APIErrorCode[\"InvalidRequestURL\"] = \"invalid_request_url\";\n  APIErrorCode[\"InvalidRequest\"] = \"invalid_request\";\n  APIErrorCode[\"ValidationError\"] = \"validation_error\";\n  APIErrorCode[\"ConflictError\"] = \"conflict_error\";\n  APIErrorCode[\"InternalServerError\"] = \"internal_server_error\";\n  APIErrorCode[\"ServiceUnavailable\"] = \"service_unavailable\";\n})(APIErrorCode = exports.APIErrorCode || (exports.APIErrorCode = {}));\n/**\n * Error codes generated for client errors.\n */\nvar ClientErrorCode;\n(function (ClientErrorCode) {\n  ClientErrorCode[\"RequestTimeout\"] = \"notionhq_client_request_timeout\";\n  ClientErrorCode[\"ResponseError\"] = \"notionhq_client_response_error\";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Base error type.\n */\nclass NotionClientErrorBase extends Error {}\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nfunction isNotionClientError(error) {\n  return (0, helpers_1.isObject)(error) && error instanceof NotionClientErrorBase;\n}\nexports.isNotionClientError = isNotionClientError;\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode(error, codes) {\n  return isNotionClientError(error) && error.code in codes;\n}\n/**\n * Error thrown by the client if a request times out.\n */\nclass RequestTimeoutError extends NotionClientErrorBase {\n  constructor(message = \"Request to Notion API has timed out\") {\n    super(message);\n    this.code = ClientErrorCode.RequestTimeout;\n    this.name = \"RequestTimeoutError\";\n  }\n  static isRequestTimeoutError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true\n    });\n  }\n  static rejectAfterTimeout(promise, timeoutMS) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError());\n      }, timeoutMS);\n      promise.then(resolve).catch(reject).then(() => clearTimeout(timeoutId));\n    });\n  }\n}\nexports.RequestTimeoutError = RequestTimeoutError;\nclass HTTPResponseError extends NotionClientErrorBase {\n  constructor(args) {\n    super(args.message);\n    this.name = \"HTTPResponseError\";\n    const {\n      code,\n      status,\n      headers,\n      rawBodyText\n    } = args;\n    this.code = code;\n    this.status = status;\n    this.headers = headers;\n    this.body = rawBodyText;\n  }\n}\nconst httpResponseErrorCodes = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\nfunction isHTTPResponseError(error) {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false;\n  }\n  return true;\n}\nexports.isHTTPResponseError = isHTTPResponseError;\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nclass UnknownHTTPResponseError extends HTTPResponseError {\n  constructor(args) {\n    var _a;\n    super({\n      ...args,\n      code: ClientErrorCode.ResponseError,\n      message: (_a = args.message) !== null && _a !== void 0 ? _a : `Request to Notion API failed with status: ${args.status}`\n    });\n    this.name = \"UnknownHTTPResponseError\";\n  }\n  static isUnknownHTTPResponseError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true\n    });\n  }\n}\nexports.UnknownHTTPResponseError = UnknownHTTPResponseError;\nconst apiErrorCodes = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nclass APIResponseError extends HTTPResponseError {\n  constructor() {\n    super(...arguments);\n    this.name = \"APIResponseError\";\n  }\n  static isAPIResponseError(error) {\n    return isNotionClientErrorWithCode(error, apiErrorCodes);\n  }\n}\nexports.APIResponseError = APIResponseError;\nfunction buildRequestError(response, bodyText) {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText);\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText\n    });\n  }\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText\n  });\n}\nexports.buildRequestError = buildRequestError;\nfunction parseAPIErrorResponseBody(body) {\n  if (typeof body !== \"string\") {\n    return;\n  }\n  let parsed;\n  try {\n    parsed = JSON.parse(body);\n  } catch (parseError) {\n    return;\n  }\n  if (!(0, helpers_1.isObject)(parsed) || typeof parsed[\"message\"] !== \"string\" || !isAPIErrorCode(parsed[\"code\"])) {\n    return;\n  }\n  return {\n    ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"]\n  };\n}\nfunction isAPIErrorCode(code) {\n  return typeof code === \"string\" && code in apiErrorCodes;\n}","map":{"version":3,"names":["helpers_1","require","APIErrorCode","exports","ClientErrorCode","NotionClientErrorBase","Error","isNotionClientError","error","isObject","isNotionClientErrorWithCode","codes","code","RequestTimeoutError","constructor","message","RequestTimeout","name","isRequestTimeoutError","rejectAfterTimeout","promise","timeoutMS","Promise","resolve","reject","timeoutId","setTimeout","then","catch","clearTimeout","HTTPResponseError","args","status","headers","rawBodyText","body","httpResponseErrorCodes","ResponseError","Unauthorized","RestrictedResource","ObjectNotFound","RateLimited","InvalidJSON","InvalidRequestURL","InvalidRequest","ValidationError","ConflictError","InternalServerError","ServiceUnavailable","isHTTPResponseError","UnknownHTTPResponseError","_a","isUnknownHTTPResponseError","apiErrorCodes","APIResponseError","isAPIResponseError","buildRequestError","response","bodyText","apiErrorResponseBody","parseAPIErrorResponseBody","undefined","parsed","JSON","parse","parseError","isAPIErrorCode"],"sources":["/Users/isa/Desktop/notion-recipes/notion-recipe-web/node_modules/@notionhq/client/src/errors.ts"],"sourcesContent":["import { SupportedResponse } from \"./fetch-types\"\nimport { isObject } from \"./helpers\"\nimport { Assert } from \"./type-utils\"\n\n/**\n * Error codes returned in responses from the API.\n */\nexport enum APIErrorCode {\n  Unauthorized = \"unauthorized\",\n  RestrictedResource = \"restricted_resource\",\n  ObjectNotFound = \"object_not_found\",\n  RateLimited = \"rate_limited\",\n  InvalidJSON = \"invalid_json\",\n  InvalidRequestURL = \"invalid_request_url\",\n  InvalidRequest = \"invalid_request\",\n  ValidationError = \"validation_error\",\n  ConflictError = \"conflict_error\",\n  InternalServerError = \"internal_server_error\",\n  ServiceUnavailable = \"service_unavailable\",\n}\n\n/**\n * Error codes generated for client errors.\n */\nexport enum ClientErrorCode {\n  RequestTimeout = \"notionhq_client_request_timeout\",\n  ResponseError = \"notionhq_client_response_error\",\n}\n\n/**\n * Error codes on errors thrown by the `Client`.\n */\nexport type NotionErrorCode = APIErrorCode | ClientErrorCode\n\n/**\n * Base error type.\n */\nabstract class NotionClientErrorBase<\n  Code extends NotionErrorCode\n> extends Error {\n  abstract code: Code\n}\n\n/**\n * Error type that encompasses all the kinds of errors that the Notion client will throw.\n */\nexport type NotionClientError =\n  | RequestTimeoutError\n  | UnknownHTTPResponseError\n  | APIResponseError\n\n// Assert that NotionClientError's `code` property is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertCodeIsNarrow = Assert<NotionErrorCode, NotionClientError[\"code\"]>\n\n// Assert that the type of `name` in NotionErrorCode is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertNameIsNarrow = Assert<\n  \"RequestTimeoutError\" | \"UnknownHTTPResponseError\" | \"APIResponseError\",\n  NotionClientError[\"name\"]\n>\n\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nexport function isNotionClientError(\n  error: unknown\n): error is NotionClientError {\n  return isObject(error) && error instanceof NotionClientErrorBase\n}\n\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode<Code extends NotionErrorCode>(\n  error: unknown,\n  codes: { [C in Code]: true }\n): error is NotionClientError & { code: Code } {\n  return isNotionClientError(error) && error.code in codes\n}\n\n/**\n * Error thrown by the client if a request times out.\n */\nexport class RequestTimeoutError extends NotionClientErrorBase<ClientErrorCode.RequestTimeout> {\n  readonly code = ClientErrorCode.RequestTimeout\n  readonly name = \"RequestTimeoutError\"\n\n  constructor(message = \"Request to Notion API has timed out\") {\n    super(message)\n  }\n\n  static isRequestTimeoutError(error: unknown): error is RequestTimeoutError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true,\n    })\n  }\n\n  static rejectAfterTimeout<T>(\n    promise: Promise<T>,\n    timeoutMS: number\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError())\n      }, timeoutMS)\n\n      promise\n        .then(resolve)\n        .catch(reject)\n        .then(() => clearTimeout(timeoutId))\n    })\n  }\n}\n\ntype HTTPResponseErrorCode = ClientErrorCode.ResponseError | APIErrorCode\n\nclass HTTPResponseError<\n  Code extends HTTPResponseErrorCode\n> extends NotionClientErrorBase<Code> {\n  readonly name: string = \"HTTPResponseError\"\n  readonly code: Code\n  readonly status: number\n  readonly headers: SupportedResponse[\"headers\"]\n  readonly body: string\n\n  constructor(args: {\n    code: Code\n    status: number\n    message: string\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super(args.message)\n    const { code, status, headers, rawBodyText } = args\n    this.code = code\n    this.status = status\n    this.headers = headers\n    this.body = rawBodyText\n  }\n}\n\nconst httpResponseErrorCodes: { [C in HTTPResponseErrorCode]: true } = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\nexport function isHTTPResponseError(\n  error: unknown\n): error is UnknownHTTPResponseError | APIResponseError {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false\n  }\n\n  type _assert = Assert<\n    UnknownHTTPResponseError | APIResponseError,\n    typeof error\n  >\n\n  return true\n}\n\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nexport class UnknownHTTPResponseError extends HTTPResponseError<ClientErrorCode.ResponseError> {\n  readonly name = \"UnknownHTTPResponseError\"\n\n  constructor(args: {\n    status: number\n    message: string | undefined\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super({\n      ...args,\n      code: ClientErrorCode.ResponseError,\n      message:\n        args.message ??\n        `Request to Notion API failed with status: ${args.status}`,\n    })\n  }\n\n  static isUnknownHTTPResponseError(\n    error: unknown\n  ): error is UnknownHTTPResponseError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true,\n    })\n  }\n}\n\nconst apiErrorCodes: { [C in APIErrorCode]: true } = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nexport class APIResponseError extends HTTPResponseError<APIErrorCode> {\n  readonly name = \"APIResponseError\"\n\n  static isAPIResponseError(error: unknown): error is APIResponseError {\n    return isNotionClientErrorWithCode(error, apiErrorCodes)\n  }\n}\n\nexport function buildRequestError(\n  response: SupportedResponse,\n  bodyText: string\n): APIResponseError | UnknownHTTPResponseError {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText)\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText,\n    })\n  }\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText,\n  })\n}\n\nfunction parseAPIErrorResponseBody(\n  body: string\n): { code: APIErrorCode; message: string } | undefined {\n  if (typeof body !== \"string\") {\n    return\n  }\n\n  let parsed: unknown\n  try {\n    parsed = JSON.parse(body)\n  } catch (parseError) {\n    return\n  }\n\n  if (\n    !isObject(parsed) ||\n    typeof parsed[\"message\"] !== \"string\" ||\n    !isAPIErrorCode(parsed[\"code\"])\n  ) {\n    return\n  }\n\n  return {\n    ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"],\n  }\n}\n\nfunction isAPIErrorCode(code: unknown): code is APIErrorCode {\n  return typeof code === \"string\" && code in apiErrorCodes\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}